#------------------------------------------------------
# Module Name: LEC
# Date:        Mon Jan 28 12:31:09 2019
# Author:      kvu
# Type:        lec
#------------------------------------------------------
package Hydra::Setup::Flow::LEC;

use Hydra::Setup::Flow::HYDRA;

use strict;
use warnings;
use Carp;
use Exporter;
use Digest::MD5 qw(md5_hex);

our $VERSION = 1.00;
our @ISA     = qw(Exporter);

#------------------------------------------------------
# Global Variables
#------------------------------------------------------
my $glb_self_module = "$ENV{HYDRA_HOME}/lib/Hydra/Setup/Flow/LEC.pm";

#------------------------------------------------------
# Subroutines
#------------------------------------------------------

#++
# Tool: fm
# Flow: LEC
#--
sub fm_LEC {
  my ($Paramref) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  # LEC uses block/db list
  my $LibFile = &Hydra::Setup::Flow::HYDRA::INIT_LIBRARY_BLOCK($Paramref, "lec");

  # Self-parse to compile a list of all params used
  # Check each param for keys to determine iterations
  my @param_list  = &Hydra::Setup::Flow::parse_self_for_params($glb_self_module, "fm_LEC");
  my @all_keysets = ();
  foreach my $param_name (@param_list) {
    if ($param_name eq "LEC_constant") {
      # Special case for LEC_constants, which must have 2 keys when LEC is iterating
      # The first key must be the iteration name
      # A param with 1 key cannot be a default value in relation to the param with 2 keys
      if ($Paramref->has_param_keysets($param_name, 2)) {
        foreach my $aref_keys ($Paramref->get_param_keysets($param_name, 2)) {
          push(@all_keysets, [$aref_keys->[0]]);
        }
      }
    }
    else {
      if ($Paramref->has_param_keysets($param_name, 1)) {
        push(@all_keysets, $Paramref->get_param_keysets($param_name, 1));
      }
    }
  }

  # Remove duplicate keysets
  my %found   = ();
  my @keysets = ();
  foreach my $aref_keys (@all_keysets) {
    if (!defined $found{md5_hex(@$aref_keys)}) {
      push(@keysets, $aref_keys);
      $found{md5_hex(@$aref_keys)} = 1;
    }
  }

  # Add the "default" keyset if there are no keysets
  if (scalar(@keysets) <= 0) {
    push(@keysets, ["default"]);
  }

  my $KickoffFile = new Hydra::Setup::File("HYDRA.run", "lec");
  $KickoffFile->make_executable;
  my $time = localtime;
  $KickoffFile->add_line("#!/usr/bin/bash");
  $KickoffFile->add_line("# Generated by Hydra on $time");
  $KickoffFile->add_line("export HYDRA_HOME=$ENV{HYDRA_HOME}");
  $KickoffFile->add_linebreak;

  #my @keysets = $Paramref->get_param_keysets("SCENARIO", 4);
  my @ScriptFiles = ();
  my @script_file_names = ();
  foreach my $aref_keys (@keysets) {
    my $script_name;
    my $iter_name;
    if ($aref_keys->[0] eq "default") {
      $script_name = "script/lec.tcl";
    }
    else {
      $iter_name   = $aref_keys->[0];
      $script_name = "script/$aref_keys->[0].lec.tcl";
    }

    my $ScriptFile = new Hydra::Setup::File($script_name, "lec");
    push(@ScriptFiles, $ScriptFile);
    push(@script_file_names, $script_name);
    my $line = "";

    $line .= sprintf <<EOF;
source script/lec_init_library.tcl

set_host_options -max_cores 4
set verification_clock_gate_edge_analysis true
EOF

    my $enable_ignore_undriven = $Paramref->get_param_value("LEC_enable_ignore_undriven", "relaxed", @$aref_keys);
    if (&Hydra::Setup::Param::is_on($enable_ignore_undriven)) {
      $line .= "set verification_set_undriven_signals X\n";
    }

    my $macros = $Paramref->get_param_value("LEC_macros", "relaxed", @$aref_keys);
    if (&Hydra::Setup::Param::has_value($macros)) {
      $line .= "set hdlin_interface_only {$macros}\n";
    }
    $line .= "\n";

    # SVF
    my $svf = $Paramref->get_param_value("LEC_svf", "relaxed", @$aref_keys);
    if (&Hydra::Setup::Param::has_value($svf)) {
      $line .= "# SVF File\n";
      $line .= "set synopsys_auto_setup true\n";
      $line .= "set_svf -ordered $svf\n";
      $line .= "\n";
    }

    # Read the first DB list available; corner doesnt matter
    my $db_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "LEC", "db");
    $line .= "# Read Libraries\n";
    $line .= "read_db \$$db_var\n";
    $line .= "\n";

    # Read input design files
    my $ref_netlist  = $Paramref->get_param_value("LEC_ref_netlist", "strict", @$aref_keys);
    my @ref_netlists = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($ref_netlist));
    my $imp_netlist  = $Paramref->get_param_value("LEC_imp_netlist", "strict", @$aref_keys);
    my @imp_netlists = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($imp_netlist));

    my @flists = ();
    $line .= "# Setup Reference\n";
    foreach my $ref_netlist (@ref_netlists) {
      my $ref_read_verilog_command = "read_verilog";
      if ($ref_netlist =~ /\.f$/) {
        # Store flists to add to init_library.tcl later
        push(@flists, $ref_netlist);

        $ref_netlist = "[concat \"\$REF_RTL\"]";
        $ref_read_verilog_command = "read_sverilog";
      }
      elsif ($ref_netlist =~ /\.ddc$/) {
        $ref_netlist = "{ $ref_netlist }";
        $ref_read_verilog_command = "read_ddc";
      }
      else {
        $ref_netlist = "{ $ref_netlist }";
      }
      $line .= "$ref_read_verilog_command -r $ref_netlist\n";
    }
    $line .= "set_top r:/WORK/$design_name\n";
    $line .= "\n";
    if (scalar(@flists) > 0) {
      &Hydra::Setup::Flow::HYDRA::add_rtl_to_lib($LibFile, \@flists, "REF_RTL");
    }

    @flists = ();
    $line .= "# Setup Implementation\n";
    foreach my $imp_netlist (@imp_netlists) {
      my $imp_read_verilog_command = "read_verilog";
      if ($imp_netlist =~ /\.f$/) {
        # Store flists to add to init_library.tcl later
        push(@flists, $imp_netlist);

        $imp_netlist = "[concat \"\$IMP_RTL\"]";
        $imp_read_verilog_command = "read_sverilog";
      }
      elsif ($imp_netlist =~ /\.ddc$/) {
        $imp_netlist = "{ $imp_netlist }";
        $imp_read_verilog_command = "read_ddc";
      }
      else {
        $imp_netlist = "{ $imp_netlist }";
      }
      $line .= "$imp_read_verilog_command -i $imp_netlist\n";
    }
    $line .= "set_top i:/WORK/$design_name\n";
    $line .= "\n";
    if (scalar(@flists) > 0) {
      &Hydra::Setup::Flow::HYDRA::add_rtl_to_lib($LibFile, \@flists, "IMP_RTL");
    }

    # Constants
    $line .= "# Constant signals\n";
    if ($aref_keys->[0] eq "default") {
      if ($Paramref->has_param_keysets("LEC_constant", 1)) {
        my @subkeysets = $Paramref->get_param_keysets("LEC_constant", 1);
        foreach my $aref_subkeys (sort { $a->[0] cmp $b->[0] } @subkeysets) {
          my $const_value = $Paramref->get_param_value("LEC_constant", "relaxed", @$aref_subkeys);
          my $const_name  = $aref_subkeys->[0];
          $line .= "set_constant r:/WORK/${design_name}/${const_name} ${const_value}\n";
          $line .= "set_constant i:/WORK/${design_name}/${const_name} ${const_value}\n";
        }
      }
    }
    else {
      if ($Paramref->has_param_keysets("LEC_constant", 2)) {
        my @subkeysets = $Paramref->get_param_keysets("LEC_constant", 2);
        foreach my $aref_subkeys (sort { $a->[1] cmp $b->[1] } @subkeysets) {
          next if ($aref_subkeys->[0] ne $aref_keys->[0]);
          my $const_value = $Paramref->get_param_value("LEC_constant", "relaxed", @$aref_subkeys);
          my $const_name  = $aref_subkeys->[1];
          $line .= "set_constant r:/WORK/${design_name}/${const_name} ${const_value}\n";
          $line .= "set_constant i:/WORK/${design_name}/${const_name} ${const_value}\n";
        }
      }
    }
    $line .= "\n";

    # Black boxes
    my $bbox_value = $Paramref->get_param_value("LEC_bbox_insts", "relaxed", @$aref_keys);
    if (&Hydra::Setup::Param::has_value($bbox_value)) {
      $bbox_value = &Hydra::Setup::Param::remove_param_value_linebreak($bbox_value);
      foreach my $inst_name (split(/\s+/, $bbox_value)) {
        $line .= "set_black_box r:/WORK/${design_name}/${inst_name}\n";
        $line .= "set_black_box i:/WORK/${design_name}/${inst_name}\n";
      }
      $line .= "\n";
    }

    # Source catchalls
    $line .= &Hydra::Setup::Flow::write_source_catchall($Paramref, "LEC", @$aref_keys);

    $line .= sprintf <<EOF;
# Verify
match
verify

EOF
    
    if (defined $iter_name) {
      $line .= sprintf <<EOF;
save_session -replace ./db/${iter_name}.fm.session

# Reports
report_black_boxes         > rpt/${iter_name}.black_boxes.rpt
report_failing_points      > rpt/${iter_name}.failing_points.rpt
report_not_compared_points > rpt/${iter_name}.not_compared_points.rpt
report_unmatched_points    > rpt/${iter_name}.unmatched_points.rpt

EOF
    }
    else {
      $line .= sprintf <<EOF;
save_session -replace ./db/fm.session

# Reports
report_black_boxes         > rpt/black_boxes.rpt
report_failing_points      > rpt/failing_points.rpt
report_not_compared_points > rpt/not_compared_points.rpt
report_unmatched_points    > rpt/unmatched_points.rpt
report_dont_verify_points  > rpt/dont_verify_points.rpt

EOF
    }

    $line .= "exit\n";
    $line .= "\n";
    $ScriptFile->add_line($line);
    
    my $tool_command;
    if (defined $iter_name) {
      $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, $script_name, "-overwrite -name_suffix _${iter_name}");
    }
    else {
      $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, $script_name);
    }
    $KickoffFile->add_line($tool_command);
  }

  # Run scripts
  #my $KickoffFile = new Hydra::Setup::File("HYDRA.run", "lec");
  #&Hydra::Setup::Flow::write_std_kickoff($Paramref, $KickoffFile, @script_file_names);

  return ($LibFile, @ScriptFiles, $KickoffFile);
}

#++
# Tool: fm
# Flow: LEC_ECO
# Subtype: eco
#--
sub fm_LEC_ECO {
  my ($Paramref, $KickoffFile) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");
  my $eco_name    = $Paramref->get_name;

  # Self-parse to compile a list of all params used
  # Check each param for keys to determine iterations
  my @param_list  = &Hydra::Setup::Flow::parse_self_for_params($glb_self_module, "fm_LEC_ECO");
  my @all_keysets = ();
  foreach my $param_name (@param_list) {
    if ($Paramref->has_param_keysets($param_name, 1)) {
      push(@all_keysets, $Paramref->get_param_keysets($param_name, 1));
    }
  }

  # Remove duplicate keysets
  my %found   = ();
  my @keysets = ();
  foreach my $aref_keys (@all_keysets) {
    if (!defined $found{md5_hex(@$aref_keys)}) {
      push(@keysets, $aref_keys);
      $found{md5_hex(@$aref_keys)} = 1;
    }
  }

  # Add the "default" keyset if there are no keysets
  if (scalar(@keysets) <= 0) {
    push(@keysets, ["default"]);
  }

  my @ScriptFiles = ();
  foreach my $aref_keys (@keysets) {
    my $script_name;
    my $iter_name;
    if ($aref_keys->[0] eq "default") {
      $script_name = "script/lec.${eco_name}.tcl";
    }
    else {
      $iter_name   = $aref_keys->[0];
      $script_name = "script/$aref_keys->[0].lec.${eco_name}.tcl";
    }

    my $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, "lec", $script_name);
    $KickoffFile->add_line($tool_command);

    my $File = new Hydra::Setup::File($script_name, "lec", "eco");
    push(@ScriptFiles, $File);
    my $line = "";

    my $session = $Paramref->get_param_value("LEC_ECO_session", "strict", @$aref_keys);
    my $eco_script = $Paramref->get_param_value("LEC_ECO_script", "strict", @$aref_keys);
    $line .= sprintf <<EOF;
restore_session ${session}

setup
edit_design i:/WORK/${design_name}

source ${eco_script}

verify_edits

if [string equal \$verification_status "SUCCEEDED"] {
  setup
  remove_verify_points -all
  verify
}

EOF

    if (defined $iter_name) {
      $line .= sprintf <<EOF;
if [string equal \$verification_status "SUCCEEDED"] {
  report_edits > rpt/${iter_name}.edits.${eco_name}.rpt
  write_edits    output/${iter_name}.lec_eco.${eco_name}.tcl
}

exit

EOF
    }
    else {
      $line .= sprintf <<EOF;
if [string equal \$verification_status "SUCCEEDED"] {
  report_edits > rpt/edits.${eco_name}.rpt
  write_edits    output/lec_eco.${eco_name}.tcl
}

exit

EOF
    }

    $File->add_line($line);
  }

  return (@ScriptFiles);
}

=pod

=head1 fm LEC

Multiple iterations of LEC can be generated using param keys. Define a param key on any LEC param to activate.

 LEC_ref_netlist(rtl2synth) = rtl.v
 LEC_ref_netlist(synth2pnr) = synth.v

=over

=item SCENARIO

Specify the scenarios that will be run. Use param keys for mode, process, temperature, and RC corner. The param key order matters. The value is a space-delimited list indicating what flow types the scenario is valid for. Use "lec" for LEC. For LEC, this is used only to select the library corner (process and temperature) that will be used.
 SCENARIO(<mode>)(<process>)(<temp>)(<rc>) = <value>
 SCENARIO(func)(ff_0p99)(125c)(cbest) = lec

=item LEC_ref_netlist

The reference netlist. If the file given has an extension of ".f", then it is assumed to be an RTL flist.

=item LEC_imp_netlist

The implementation netlist. If the file given has an extension of ".f", then it is assumed to be an RTL flist.

=item LEC_bbox_insts

Instances to be black-boxed. Use a space-delimited list. If you use this, your modules must be defined during design read-in.

=item LEC_enable_ignore_undriven

Set undriven signals to be ignored. On or off.

=item LEC_constant

For specifying constant signals. Use param keys.

 LEC_constant(<key>) = <value>
 LEC_constant(RESET) = 0

If you are generating multiple iterations of LEC, use two param keys: the first must be the iteration and the second must be the signal.

 LEC_constant(rtl2synth)(RESET) = 0

=item LEC_source_catchall_local

A space-delimited list of misc source scripts.

=item LEC_source_catchall_global

A space-delimited list of misc source scripts.

=item LEC_macros

A space-delimited list of modules that should be black boxed. If you use this, your modules can be undefined during design read-in.

=item DB_block_list

Specify your block dbs. Unlike DB_std_list and DB_macro_list, param keys for DB_block_list are optional.

=back

=head1 fm LEC_ECO

This flow is meant to facilitate ECOs done in Formality. It is for cases where you have a v2 reference that you wish to pass LEC against a v1 implementation. The idea is to perform an ECO on the v1 implementation directly in Formality so that it will match the v2 reference.

The resulting output ECO script can be used as a base for performing the ECO after PNR; the output script is sourceable by PNR tools but will likely need to be modified to reflect the changes made by PNR.

Multiple iterations of LEC can be generated using param keys. Define a param key on any LEC param to activate.

 LEC_ECO_script(rtl2synth) = rtl2synth.tcl 
 LEC_ECO_script(synth2pnr) = synth2pnr.tcl

=over

=item LEC_ECO_script

A script containing design edit commands. This script will act on the v1 implementation.

=item LEC_ECO_session

The Formality session to base this ECO run off of. This session should be for the v2 reference against the v1 implementation.

=back

=cut

1;
