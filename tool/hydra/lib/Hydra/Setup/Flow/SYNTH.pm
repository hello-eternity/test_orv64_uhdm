#------------------------------------------------------
# Module Name: SYNTH
# Date:        Fri Feb 15 10:53:55 2019
# Author:      kvu
# Type:        synth
#------------------------------------------------------
package Hydra::Setup::Flow::SYNTH;

use strict;
use warnings;
use Carp;
use Exporter;
use Digest::MD5 qw(md5_hex);

our $VERSION = 1.00;
our @ISA     = qw(Exporter);

#------------------------------------------------------
# Global Variables
#------------------------------------------------------
my $glb_self_module = "$ENV{HYDRA_HOME}/lib/Hydra/Setup/Flow/SYNTH.pm";

#------------------------------------------------------
# Subroutines
#------------------------------------------------------

#++
# Tool: dc
# Flow: SYNTH
#--
sub dc_SYNTH {
  my ($Paramref) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  my $LibFile = &Hydra::Setup::Flow::HYDRA::INIT_LIBRARY($Paramref, "synth");

  # Run scripts
  my $KickoffFile = new Hydra::Setup::File("HYDRA.run", "synth");
  #&Hydra::Setup::Flow::write_std_kickoff($Paramref, $KickoffFile, ("script/synth.tcl"));
  my $time = localtime;
  $KickoffFile->add_line("#!/usr/bin/bash");
  $KickoffFile->add_line("# Generated by Hydra on $time");
  $KickoffFile->add_line("export HYDRA_HOME=$ENV{HYDRA_HOME}");
  $KickoffFile->add_linebreak;
  my $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, "script/synth.tcl");
  $KickoffFile->add_line($tool_command);
  $KickoffFile->make_executable;

  # Tool scripts
  my $ScriptFile = new Hydra::Setup::File("script/synth.tcl", "synth");
  my $line = "";

  $line .= sprintf <<EOF;
echo \"RUN STARTED AT [date]\"
source script/synth_init_library.tcl
set_svf ./output/${design_name}.synth.svf

# Tool settings
set_app_var sh_new_variable_message                     false
set_app_var report_default_significant_digits           3
set_app_var hdlin_infer_multibit                        default_all
set_app_var compile_clock_gating_through_hierarchy      true
set_app_var hdlin_enable_upf_compatible_naming          true
set_app_var compile_timing_high_effort_tns              true
set_app_var compile_clock_gating_through_hierarchy      true
set_app_var hdlin_enable_hier_map                       true

EOF

  # User app vars
  if ($Paramref->has_param_keysets("SYNTH_app_vars", 1)) {
    my @app_var_keysets = $Paramref->get_param_keysets("SYNTH_app_vars", 1);
    foreach my $aref_keys (@app_var_keysets) {
      my ($name) = @$aref_keys;
      my $value = $Paramref->get_param_value("SYNTH_app_vars", "strict", @$aref_keys);
      $line .= sprintf "set_app_var %-43s $value\n", $name;
    }
  }
  $line .= "\n";

  my $host_options = $Paramref->get_param_value("PNR_host_options", "relaxed");
  if (&Hydra::Setup::Param::has_value($host_options)) {
    $line .= "set_host_options $host_options\n";
  }

  my $db_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "SYNTH", "db");
  $line .= sprintf <<EOF;
### Logical Library
set_app_var search_path "."

set_app_var target_library [concat \"\$$db_var\"]
set_app_var link_library [concat "*" dw_foundation.sldb \$target_library]
set_app_var synthetic_library \"dw_foundation.sldb\"

EOF

  my $macros = $Paramref->get_param_value("SYNTH_macros", "relaxed");
  $line .= "### Read in the design\n";
  if (&Hydra::Setup::Param::has_value($macros)) {
    $line .= "set_app_var hdlin_sv_interface_only_modules {$macros}\n";
  }
  $line .= "define_design_lib WORK -path ./WORK\n";
  $line .= "\n";

  $line .= &Hydra::Setup::Flow::write_source_catchall($Paramref, "SYNTH");

  my $define    = $Paramref->get_param_value("SYNTH_define", "relaxed");
  my $rtl_flist = $Paramref->get_param_value("SYNTH_rtl_flist", "strict");
  my @flists = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($rtl_flist));
  &Hydra::Setup::Flow::HYDRA::add_rtl_to_lib($LibFile, \@flists);
  if (&Hydra::Setup::Param::has_value($define)) {
    $define = &Hydra::Setup::Param::remove_param_value_linebreak($define);
    $define =~ s/^\s*//;
    $define =~ s/\s*$//;
    $define =~ s/\s+/ /g;
    $define = "{ " . $define . " }";
    
    $line .= "analyze -define $define -format sverilog [concat \"\$RTL\"]\n";
  }
  else {
    $line .= "analyze -format sverilog [concat \"\$RTL\"]\n";
  }

  $line .= sprintf <<EOF;
elaborate      ${design_name}
current_design ${design_name}

EOF

  my $post_elab_catchall = $Paramref->get_param_value("SYNTH_source_catchall_post_elab", "relaxed");
  if (&Hydra::Setup::Param::has_value($post_elab_catchall)) {
    $line .= &Hydra::Setup::Flow::write_repeating_param("source", $post_elab_catchall);
    $line .= "\n";
  }

  $line .= sprintf <<EOF;
# DesignWare settinqgs
set_dp_smartgen_options -hierarchy -smart_compare true -tp_oper_sel auto -tp_opt_tree auto  -brent_kung_adder true -adder_radix auto -inv_out_adder_cell auto -mult_radix4 auto -sop2pos_transformation auto  -mult_arch auto -optimize_for area,speed 
analyze_datapath_extraction -no_autoungroup

link
set_verification_top
uniquify
write_file -hierarchy -format verilog -output ./output/${design_name}.synth.elaborate.v

EOF

  $line .= "### Constraints\n";
  my $dont_use_script = $Paramref->get_param_value("SYNTH_dont_use_script", "relaxed");
  $line .= &Hydra::Setup::Flow::write_repeating_param("source", $dont_use_script);

  my $sdc = $Paramref->get_param_value("SYNTH_sdc", "relaxed");
  my $execute_commands  = $Paramref->get_param_value("SYNTH_execute_commands", "strict");
  my $optimize_commands = $Paramref->get_param_value("SYNTH_optimize_commands", "strict");
  $line .= &Hydra::Setup::Flow::write_repeating_param("source", $sdc);
  $line .= sprintf <<EOF;
write_sdc ./output/${design_name}.synth.elaborate.sdc

report_clock_tree -structure > ./rpt/clock_tree_structure.rpt

# NOTE: Uncertain if this is needed.
# set_preserve_clock_gate [get_cells * -hier -filter "ref_name=~*_clk_gating*"]

define_name_rules preserve_struct_bus_rule -preserve_struct_ports
define_name_rules ours_verilog_name_rule -allowed \"a-z A-Z 0-9 _\" \\
    -check_internal_net_name \\
    -case_insensitive 

echo [get_object_name [get_lib_cells */* -filter dont_use==true]] > rpt/dont_use_list.rpt

### Compile
check_design > ./rpt/check_design.precompile.rpt

set_dynamic_optimization true

$execute_commands

analyze_datapath > ./rpt/datapath.compile.rpt
report_resources > ./rpt/resources.compile.rpt
write_file -hierarchy -format verilog -output ./output/${design_name}.synth.compile.v        
write_sdc ./output/${design_name}.synth.compile.sdc

update_timing
report_timing -nosplit > ./rpt/timing.compile.rpt
report_area -nosplit -hier > ./rpt/area.hier.compile.rpt

### Optimize
check_design > ./rpt/check_design.preopt.rpt
$optimize_commands
check_design > ./rpt/check_design.postopt.rpt

#rename_design -prefix \"${design_name}_\" [remove_from_collection [all_designs] [current_design]]
change_names -rules preserve_struct_bus_rule -hierarchy -log_changes ./rpt/struct_name_change.log   
change_names -rules ours_verilog_name_rule   -hierarchy -log_changes ./rpt/legalize_name_change.log 
write -format verilog -hierarchy -output ./output/${design_name}.synth.final.v
write -format ddc -hierarchy -output ./output/${design_name}.synth.final.ddc
write_sdc -nosplit ./output/${design_name}.synth.final.sdc

report_clock_gating > ./rpt/clock_gating.rpt
report_timing -max_paths 500 -significant_digits 3 -nosplit > ./rpt/synth.timing.rpt
report_timing -delay_type min -max_paths 500 -input_pins -nets -transition_time -capacitance -significant_digits 3 > ./rpt/synth.min_delay.rpt
report_timing -delay_type max -max_paths 500 -input_pins -nets -transition_time -capacitance -significant_digits 3 > ./rpt/synth.max_delay.rpt
report_constraint -all_violators -significant_digits 3 > ./rpt/synth.all_viol_constraints.rpt
report_area -nosplit -hier > ./rpt/synth.area.hier.rpt
report_resources -nosplit -hier > ./rpt/synth.resources.rpt
report_clocks -nosplit > ./rpt/clocks.rpt
report_interclock_relation -nosplit > ./rpt/interclock_relation.rpt

report_compile_options -nosplit > ./rpt/synth.compile_options.rpt

check_timing > ./rpt/check_timing.rpt

echo "RUN ENDED AT [date]"
exit

EOF

  $ScriptFile->add_line($line);

  return ($LibFile, $KickoffFile, $ScriptFile);
}

#++
# Tool: dc
# Flow: SYNTH_ECO
# Subtype: eco
#--
sub dc_SYNTH_ECO {
  my ($Paramref, $KickoffFile) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  my $LibFile = &Hydra::Setup::Flow::HYDRA::INIT_LIBRARY($Paramref, "synth", "eco");

  # Self-parse to compile a list of all params used
  # Check each param for keys to determine iterations
  my @param_list  = &Hydra::Setup::Flow::parse_self_for_params($glb_self_module, "dc_SYNTH_ECO");
  my @all_keysets = ();
  foreach my $param_name (@param_list) {
    if ($Paramref->has_param_keysets($param_name, 1)) {
      push(@all_keysets, $Paramref->get_param_keysets($param_name, 1));
    }
  }

  # Remove duplicate keysets
  my %found   = ();
  my @keysets = ();
  foreach my $aref_keys (@all_keysets) {
    if (!defined $found{md5_hex(@$aref_keys)}) {
      push(@keysets, $aref_keys);
      $found{md5_hex(@$aref_keys)} = 1;
    }
  }

  # Add the "default" keyset if there are no keysets
  if (scalar(@keysets) <= 0) {
    push(@keysets, ["default"]);
  }

  my @ScriptFiles = ();
  foreach my $aref_keys (@keysets) {
    my $script_name;
    my $iter_name;
    if ($aref_keys->[0] eq "default") {
      $script_name = "script/synth_eco.tcl";
    }
    else {
      $iter_name   = $aref_keys->[0];
      $script_name = "script/$aref_keys->[0].synth_eco.tcl";
    }

    my $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, $script_name);
    $KickoffFile->add_line($tool_command);

    my $ScriptFile = new Hydra::Setup::File($script_name, "synth", "eco");
    push(@ScriptFiles, $ScriptFile);
    my $line = "";

    $line .= sprintf <<EOF;
echo \"RUN STARTED AT [date]\"
source script/synth_init_library.tcl

EOF

    if (defined $iter_name) {
      $line .= "set_svf ./output/${design_name}.${iter_name}.synth_eco.svf\n";
    }
    else {
      $line .= "set_svf ./output/${design_name}.synth_eco.svf\n";
    }

    $line .= sprintf <<EOF;

# Tool settings
set_app_var sh_new_variable_message                     false
set_app_var report_default_significant_digits           3
set_app_var hdlin_infer_multibit                        default_all
set_app_var compile_clock_gating_through_hierarchy      true
set_app_var hdlin_enable_upf_compatible_naming          true
set_app_var compile_timing_high_effort_tns              true
set_app_var compile_clock_gating_through_hierarchy      true
set_app_var hdlin_enable_hier_map                       true

EOF

    my $host_options = $Paramref->get_param_value("PNR_host_options", "relaxed");
    if (&Hydra::Setup::Param::has_value($host_options)) {
      $line .= "set_host_options $host_options\n";
    }
    $line .= "\n";
    
    my $db_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "SYNTH", "db");
    $line .= sprintf <<EOF;
### Logical Library
set_app_var search_path "."

set_app_var target_library [concat \"\$$db_var\"]
set_app_var link_library [concat "*" dw_foundation.sldb \$target_library]
set_app_var synthetic_library \"dw_foundation.sldb\"

EOF

    my $macros = $Paramref->get_param_value("SYNTH_macros", "relaxed", @$aref_keys);
    $line .= "### Read in the design\n";
    if (&Hydra::Setup::Param::has_value($macros)) {
      $line .= "set_app_var hdlin_sv_interface_only_modules {$macros}\n";
    }
    $line .= "define_design_lib WORK -path ./WORK\n";
    $line .= "\n";
    
    my $netlist = $Paramref->get_param_value("SYNTH_ECO_verilog", "strict", @$aref_keys);
    $line .= &Hydra::Setup::Flow::write_repeating_param("read_verilog -netlist", $netlist);
    $line .= sprintf <<EOF;
current_design ${design_name}
link
set_verification_top

EOF
  
    my $eco_script = $Paramref->get_param_value("SYNTH_ECO_script", "strict", @$aref_keys);
    $line .= &Hydra::Setup::Flow::write_repeating_param("source", $eco_script);
    $line .= "\n";

    $line .= "current_design ${design_name}\n";
    
    if (defined $iter_name) {
      $line .= "write -format verilog -hierarchy -output ./output/${design_name}.${iter_name}.synth_eco.v\n";
    }
    else {
      $line .= "write -format verilog -hierarchy -output ./output/${design_name}.synth_eco.v\n";
    }

    $line .= sprintf <<EOF;

echo "RUN ENDED AT [date]"
exit

EOF

    $ScriptFile->add_line($line);
  }

  return ($LibFile, @ScriptFiles);
}

=pod

=head1 dc SYNTH

=over

=item SCENARIO

Specify the scenarios that will be run. Use param keys for mode, process, temperature, and RC corner. The param key order matters. The value is a space-delimited list indicating what flow types the scenario is valid for. Use "synth" for SYNTH. For SYNTH, this is used only to select the library corner (process and temperature) that will be used.
 SCENARIO(<mode>)(<process>)(<temp>)(<rc>) = <value>
 SCENARIO(func)(ff_0p99)(125c)(cbest) = synth

=item SYNTH_dont_use_script

A script containing "set_dont_use" commands. Set the library cells that should not be used during synthesis here.

=item SYNTH_macros

A space-delimited list of modules that should be black boxed.

=item SYNTH_rtl_flist

An flist containing RTL files.

=item SYNTH_sdc

One or more timing constraint files.

=item SYNTH_source_catchall_global

A space-delimited list of misc source scripts.

=item SYNTH_source_catchall_local

A space-delimited list of misc source scripts.

=item SYNTH_app_vars

Define extra app vars. Use param keys
  SYNTH_app_vars(<var_name>) = <value>

=item SYNTH_define

A space-delimited list of `define macros.

=back

=head1 dc SYNTH_ECO

This flow is for applying an eco to a pre-synthesized netlist. Unlike the regular SYNTH flow, only the eco'ed netlist and the svf will be generated. This is meant to be used to run LEC on a v2 RTL release against a v1 synthesized netlist with an eco applied to bring it to v2.

Multiple iterations of SYNTH_ECO can be generated using param keys. Define a param key on any SYNTH param to activeate.

 SYNTH_ECO_verilog(pnr) = pnr.v
 SYNTH_ECO_verilog(dft) = dft.v

=over

=item SYNTH_macros

A space-delimited list of modules that should be black boxed.

=item SYNTH_ECO_verilog

The verilog netlist that the eco will be applied on.

=item SYNTH_ECO_script

The eco script that will be applied on the verilog netlist.

=back

=cut

1;
