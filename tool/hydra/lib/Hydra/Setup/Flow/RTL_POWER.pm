#------------------------------------------------------
# Module Name: RTL_POWER
# Date:        Tue Apr  9 15:12:11 2019
# Author:      kvu
# Type:        rtl_power
#------------------------------------------------------
package Hydra::Setup::Flow::RTL_POWER;

use strict;
use warnings;
use Carp;
use Exporter;

our $VERSION = 1.00;
our @ISA     = qw(Exporter);

#------------------------------------------------------
# Global Variables
#------------------------------------------------------

#------------------------------------------------------
# Subroutines
#------------------------------------------------------

#++
# Tool: spyglass
# Flow: RTL_POWER
#--
sub spyglass_RTL_POWER {
  my ($Paramref) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  my @LibFiles = &Hydra::Setup::Flow::HYDRA::INIT_LIBRARY($Paramref, "rtl_power");
  
  # Run scripts
  my $KickoffFile = new Hydra::Setup::File("HYDRA.run", "rtl_power");
  #&Hydra::Setup::Flow::write_std_kickoff($Paramref, $KickoffFile, ("script/rtl_power.tcl"));
  my $time = localtime;
  $KickoffFile->add_line("#!/usr/bin/bash");
  $KickoffFile->add_line("# Generated by Hydra on $time");
  $KickoffFile->add_line("export HYDRA_HOME=$ENV{HYDRA_HOME}");
  $KickoffFile->add_line("export SKIP_PLATFORM_CHECK=1");

  # This might be dangerous
  my $dc_home = &Hydra::Setup::Tool::get_tool_binary($Paramref, "synth");
  $dc_home =~ s/\/bin\/dc_shell$//;
  $KickoffFile->add_line("export SPYGLASS_DC_PATH=${dc_home}");

  # This might also be dangerous
  my $spy_home = &Hydra::Setup::Tool::get_tool_binary($Paramref, "rtl_power");
  $spy_home =~ s/\/bin\/sg_shell$//;
  $KickoffFile->add_line("export SPYGLASS_HOME=${spy_home}");
  $KickoffFile->add_linebreak;

  # Check spyglass home for UFE version of vc shell
  if (!-f "${spy_home}/lib/multi-vcst/bin/vc_static_shell") {
    print "WARN: Non-UFE SpyGlass detected while generating RTL_POWER which uses VCS compile\n";
    print "      Change binary in HYDRA_rtl_power_bin to one with UFE\n";
  }

  my $rtl_flist = $Paramref->get_param_value("RTL_POWER_rtl_flist", "strict");
  my @flists = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($rtl_flist));
  my $flist_string = join(" ", map { "\"${_}\"" } @flists);
  $KickoffFile->add_line("\${HYDRA_HOME}/hydra.pl report_git_info -rtl_flist $flist_string -out_file ./rpt/rtl_files.list");
  $KickoffFile->add_linebreak;

  my $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, "script/rtl_power.tcl");
  $KickoffFile->add_line($tool_command);
  $KickoffFile->make_executable;

  my @ScriptFiles = ();
  my $line = "";
  my $sgdc = $Paramref->get_param_value("RTL_POWER_sgdc", "relaxed");

  if (!&Hydra::Setup::Param::has_value($sgdc)) {
    $sgdc = "./script/rtl_power.sgdc";

    # Sgdc file
    my $SGDCFile = new Hydra::Setup::File("script/rtl_power.sgdc", "rtl_power");
    $line = "";

    my $fsdb      = &Hydra::Util::File::resolve_env($Paramref->get_param_value("RTL_POWER_fsdb", "strict"));
    my $starttime = $Paramref->get_param_value("RTL_POWER_fsdb_starttime", "relaxed");
    my $endtime   = $Paramref->get_param_value("RTL_POWER_fsdb_endtime", "relaxed");
    my $top_name = $Paramref->get_param_value("RTL_POWER_testbench_top", "strict");
    my $sdc      = &Hydra::Util::File::resolve_env($Paramref->get_param_value("RTL_POWER_sdc", "strict"));
    my $cts_buf = $Paramref->get_param_value("RTL_POWER_cts_buf", "strict");
    my $fanout  = $Paramref->get_param_value("RTL_POWER_cts_max_fanout", "strict");
    $line .= sprintf <<EOF;
current_design $design_name

activity_data \\
  -format FSDB \\
  -sim_topname $top_name \\
EOF

    if (&Hydra::Setup::Param::has_value($starttime)) {
      $line .= "  -starttime $starttime \\\n";
    }
    if (&Hydra::Setup::Param::has_value($endtime)) {
      $line .= "  -endtime $endtime \\\n";
    }

    $line .= sprintf <<EOF;
  -file $fsdb

sdc_data -file $sdc

clock_buffer \\
  -cellname  $cts_buf \\
  -maxfanout $fanout

EOF

    $SGDCFile->add_line($line);
    push(@ScriptFiles, $SGDCFile);
  }
  
  # Tool scripts
  my $ScriptFile = new Hydra::Setup::File("script/rtl_power.tcl", "rtl_power");
  $line = "";

  $line .= sprintf <<EOF;
source script/rtl_power_init_library.tcl
source $ENV{HYDRA_HOME}/script/tcl/file_to_list.tcl

new_project ./db/${design_name}.prj -projectwdir "./db" -force

set_option auto_save yes
set_option enable_gateslib_autocompile yes
set_option enable_sglib_debug yes
set_option dw yes
set_option mthresh 65535
set_option include_opt_data true
set_option use_vcs_compile yes
set_option libhdl_extmap .v verilog2005
set_option hdllibdu yes
set_option disable_amg yes

EOF

  my @incdirs = ();
  my $has_v   = 0;
  my $resolved_rtl_flist = &Hydra::Util::File::resolve_env($rtl_flist);
  if (-f $resolved_rtl_flist) {
    my ($aref_files, $aref_incdirs, $flist_has_v) = &Hydra::Util::File::expand_file_list($resolved_rtl_flist);
    $has_v = $flist_has_v;
    @incdirs = @$aref_incdirs;
  }

  if ($has_v) {
    # Allow module override if -v option is used in flist
    $line .= "# Allow module redeclaration for netlist run\n";
    $line .= "set_option allow_module_override yes\n";
    $line .= "\n";
  }

  $line .= "# Read RTL\n";
  foreach my $flist (@flists) {
    $line .= "read_file -type hdl [concat [expand_file_list \"${flist}\"]]\n"
  }

  my $lib_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "RTL_POWER", "lib");
  $line .= sprintf <<EOF;
read_file -type gateslib [concat \"\$$lib_var\"]
read_file -type sgdc $sgdc

EOF

  # my @incdirs = ();
  # my $resolved_rtl_flist = &Hydra::Util::File::resolve_env($rtl_flist);
  # if (-f $resolved_rtl_flist) {
  #   my ($aref_files, $aref_incdirs) = &Hydra::Util::File::expand_file_list($resolved_rtl_flist);
  #   @incdirs = @$aref_incdirs;
  # }
  if (scalar(@incdirs) > 0) {
    my $dir_list = "\"" . join(" ", @incdirs) . "\"";
    $line .= "set_option incdir $dir_list\n";
  }
  # foreach my $incdir (@incdirs) {
  #   $line .= "set_option incdir $incdir\n";
  # }

  my $define = $Paramref->get_param_value("RTL_POWER_define", "relaxed");
  $line .= &Hydra::Setup::Flow::write_repeating_param("set_option define", $define);
  $line .= "\n";

  $line .= sprintf <<EOF;

set_option enableSV09 yes
set_option top ${design_name}
current_methodology \$SPYGLASS_HOME/GuideWare/latest/block/initial_rtl

EOF
# # Sanity check inputs
# current_goal power/power_audit
# set_parameter pe_logic_depth 50
# set_parameter pe_enable_monitor_on_dw_nets yes
# set_parameter pe_enable_monitor_on_all_nets yes

# EOF

  my $threshold = $Paramref->get_param_value("RTL_POWER_clock_gating_threshold", "relaxed");
#   if (&Hydra::Setup::Param::has_value($threshold)) {
#     $line .= "set_goal_option sgsyn_clock_gating_threshold ${threshold}\n"
#   }

  my $scan_ins = $Paramref->get_param_value("RTL_POWER_enable_scan_ins", "relaxed");
#   if (&Hydra::Setup::Param::is_on($scan_ins)) {
#     $line .= "set_option use_scan_flops yes\n";
#   }
#   else {
#     $line .= "set_option use_scan_flops no\n";
#   }

#   $line .= sprintf <<EOF;

# run_goal

# current_goal power/power_est_average
# set_parameter pe_logic_depth 50
# set_parameter pe_enable_monitor_on_dw_nets yes
# set_parameter pe_enable_monitor_on_all_nets yes

# EOF

#   if (&Hydra::Setup::Param::has_value($threshold)) {
#     $line .= "set_goal_option sgsyn_clock_gating_threshold ${threshold}\n"
#   }

#   if (&Hydra::Setup::Param::is_on($scan_ins)) {
#     $line .= "set_option use_scan_flops yes\n";
#   }
#   else {
#     $line .= "set_option use_scan_flops no\n";
#   }

#   $line .= sprintf <<EOF;

# run_goal

    $line .= sprintf <<EOF;

current_goal power/power_est_profiling
set_parameter pe_logic_depth 50
set_parameter pe_enable_monitor_on_dw_nets yes
set_parameter pe_enable_monitor_on_all_nets yes
set_parameter pe_generate_fsdb 1

EOF

  if (&Hydra::Setup::Param::has_value($threshold)) {
    $line .= "set_goal_option sgsyn_clock_gating_threshold ${threshold}\n"
  }

  if (&Hydra::Setup::Param::is_on($scan_ins)) {
    $line .= "set_option use_scan_flops yes\n";
  }
  else {
    $line .= "set_option use_scan_flops no\n";
  }

  my $ignorerules = $Paramref->get_param_value("RTL_POWER_ignorerules", "relaxed");
  if (&Hydra::Setup::Param::has_value($ignorerules)) {
    $line .= "set_goal_option ignorerules {${ignorerules}}\n";
  }

  $line .= sprintf <<EOF;

run_goal

save_project

write_aggregate_report project_summary -reportdir "./rpt"

exit

EOF

  $ScriptFile->add_line($line);
  push(@ScriptFiles, $ScriptFile);

  return (@LibFiles, @ScriptFiles, $KickoffFile);

}

#++
# Tool: joules
# Flow: RTL_POWER
#--
sub joules_RTL_POWER {
  my ($Paramref) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  my @LibFiles = &Hydra::Setup::Flow::HYDRA::INIT_LIBRARY($Paramref, "rtl_power");
  
  # Run scripts
  my $KickoffFile = new Hydra::Setup::File("HYDRA.run", "rtl_power");
  #&Hydra::Setup::Flow::write_std_kickoff($Paramref, $KickoffFile, ("script/rtl_power.tcl"));
  
  my $time = localtime;
  $KickoffFile->add_line("#!/usr/bin/bash");
  $KickoffFile->add_line("# Generated by Hydra on $time");
  $KickoffFile->add_line("export HYDRA_HOME=$ENV{HYDRA_HOME}");
  $KickoffFile->add_linebreak;
  
  my $rtl_flist = $Paramref->get_param_value("RTL_POWER_rtl_flist", "strict");
  my @flists = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($rtl_flist));
  my $flist_string = join(" ", map { "\"${_}\"" } @flists);
  $KickoffFile->add_line("\${HYDRA_HOME}/hydra.pl report_git_info -rtl_flist $flist_string -out_file ./rpt/rtl_files.list");
  $KickoffFile->add_linebreak;
  
  my $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, "script/rtl_power.tcl");
  $KickoffFile->add_line($tool_command);
  $KickoffFile->make_executable;

  my @ScriptFiles = ();
  my $ScriptFile = new Hydra::Setup::File("script/rtl_power.tcl", "rtl_power");
  my $line = "";

  my $lib_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "RTL_POWER", "lib");
  my @incdirs = ();
  my $has_v   = 0;
  my $resolved_rtl_flist = &Hydra::Util::File::resolve_env($rtl_flist);
  if (-f $resolved_rtl_flist) {
    my ($aref_files, $aref_incdirs, $flist_has_v) = &Hydra::Util::File::expand_file_list($resolved_rtl_flist);
    $has_v = $flist_has_v;
    @incdirs = @$aref_incdirs;
  }
  my $incdirs_string = join(" ", @incdirs);
  $line .= sprintf <<EOF;
source script/rtl_power_init_library.tcl
source $ENV{HYDRA_HOME}/script/tcl/file_to_list.tcl

read_libs [concat \"\$$lib_var\"]

set_attribute init_hdl_search_path \"$incdirs_string\"
EOF

  my $define = $Paramref->get_param_value("RTL_POWER_define", "relaxed");
  my $define_string = "";
  if (&Hydra::Setup::Param::has_value($define)) {
    my @defines = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($define));
    foreach my $single_define (@defines) {
      $define_string .= "-define $single_define ";
    }
  }
  foreach my $flist (@flists) {
    $line .= "read_hdl -sv $define_string [concat [expand_file_list \"${flist}\"]]\n";
  }

  my $sdc  = &Hydra::Util::File::resolve_env($Paramref->get_param_value("RTL_POWER_sdc", "strict"));
  my $threshold = $Paramref->get_param_value("RTL_POWER_clock_gating_threshold", "relaxed");
  my $thresh_command = "";
  if (&Hydra::Setup::Param::has_value($threshold)) {
    $thresh_command = "set_attribute lp_clock_gating_max_flops $threshold\n";
  }
  $line .= sprintf <<EOF;

set_attribute lp_insert_clock_gating true
$thresh_command
elaborate pygmy_e

read_sdc $sdc
syn_generic pygmy_e

EOF

  my $fsdb      = &Hydra::Util::File::resolve_env($Paramref->get_param_value("RTL_POWER_fsdb", "strict"));
  my $starttime = $Paramref->get_param_value("RTL_POWER_fsdb_starttime", "relaxed");
  my $endtime   = $Paramref->get_param_value("RTL_POWER_fsdb_endtime", "relaxed");
  my $top_name = $Paramref->get_param_value("RTL_POWER_testbench_top", "strict");
  $line .= sprintf <<EOF;
read_stimulus \\
  -multi_host_read \\
  -format fsdb \\
  -dut_instance top.dut \\
EOF

  if (&Hydra::Setup::Param::has_value($starttime)) {
    $line .= "  -start $starttime \\\n";
  }
  if (&Hydra::Setup::Param::has_value($endtime)) {
    $line .= "  -end $endtime \\\n";
  }

  $line .= sprintf <<EOF;
  -sdb_out db/waves.sdb \\
  -file $fsdb

syn_power -leakage_power_effort medium
check_design -unresolved > rpt/unresolved.rpt

EOF

  my $scan_ins = $Paramref->get_param_value("RTL_POWER_enable_scan_ins", "relaxed");
  if (&Hydra::Setup::Param::is_on($scan_ins)) {
    $line .= "replace_scan\n\n";
  }

  my $cts_buf = &Hydra::Setup::Param::remove_param_value_linebreak($Paramref->get_param_value("RTL_POWER_cts_buf", "strict"));
  $line .= "create_clock_tree -clock_buffers $cts_buf\n\n";

  $line .= sprintf <<EOF;
compute_power -auto_tune logic
report_power > rpt/power.rpt
report_power -by_hierarchy > rpt/hier.power.rpt
report_power -by_leaf_instance > rpt/flat.power.rpt
report_ppa > rpt/ppa.rpt

# Use option -db with joules binary to open this db
write_db -all -to_file db/rtl_power.db

exit

EOF

  $ScriptFile->add_line($line);
  push(@ScriptFiles, $ScriptFile);

  return (@LibFiles, @ScriptFiles, $KickoffFile);
}

#++
# Tool: powerartist
# Flow: RTL_POWER
#--
sub powerartist_RTL_POWER {
  my ($Paramref) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  my @LibFiles = &Hydra::Setup::Flow::HYDRA::INIT_LIBRARY($Paramref, "rtl_power");
  
  # Run scripts
  my $KickoffFile = new Hydra::Setup::File("HYDRA.run", "rtl_power");
  #&Hydra::Setup::Flow::write_std_kickoff($Paramref, $KickoffFile, ("script/rtl_power.tcl"));
  
  my $time = localtime;
  $KickoffFile->add_line("#!/usr/bin/bash");
  $KickoffFile->add_line("# Generated by Hydra on $time");
  $KickoffFile->add_line("export HYDRA_HOME=$ENV{HYDRA_HOME}");

  # This might be dangerous
  my $dc_home = &Hydra::Setup::Tool::get_tool_binary($Paramref, "synth");
  $dc_home =~ s/\/dc_shell$//;
  $KickoffFile->add_line("export PATH=\$PATH:${dc_home}");

  $KickoffFile->add_linebreak;
  
  my $rtl_flist = $Paramref->get_param_value("RTL_POWER_rtl_flist", "strict");
  my @flists = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($rtl_flist));
  my $flist_string = join(" ", map { "\"${_}\"" } @flists);
  $KickoffFile->add_line("\${HYDRA_HOME}/hydra.pl report_git_info -rtl_flist $flist_string -out_file ./rpt/rtl_files.list");
  $KickoffFile->add_linebreak;
  
  my $tool_command = &Hydra::Setup::Tool::get_tool_command($Paramref, $KickoffFile->get_type, "script/rtl_power.tcl");
  $KickoffFile->add_line($tool_command);
  $KickoffFile->make_executable;

  my @ScriptFiles = ();
  my $ScriptFile = new Hydra::Setup::File("script/rtl_power.tcl", "rtl_power");
  my $line = "";

  my $lib_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "RTL_POWER", "lib");
  my @incdirs = ();
  my $has_v   = 0;
  my $resolved_rtl_flist = &Hydra::Util::File::resolve_env($rtl_flist);
  if (-f $resolved_rtl_flist) {
    my ($aref_files, $aref_incdirs, $flist_has_v) = &Hydra::Util::File::expand_file_list($resolved_rtl_flist);
    $has_v = $flist_has_v;
    @incdirs = @$aref_incdirs;
  }
  my $incdirs_string = join(" ", @incdirs);

  my $scan_ins = $Paramref->get_param_value("RTL_POWER_enable_scan_ins", "relaxed");
  my $scan_string = "pa_set use_non_scan_flops true";
  if (&Hydra::Setup::Param::is_on($scan_ins)) {
    $scan_string = "pa_set use_non_scan_flops false";
  }

  $line .= sprintf <<EOF;
source script/rtl_power_init_library.tcl
source $ENV{HYDRA_HOME}/script/tcl/file_to_list.tcl

$scan_string

ReadLibrary -name [concat \"\$$lib_var\"]

SetIncDirPath $incdirs_string
EOF

  my $define = $Paramref->get_param_value("RTL_POWER_define", "relaxed");
  if (&Hydra::Setup::Param::has_value($define)) {
    my @defines = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($define));
    foreach my $single_define (@defines) {
      $line .= "SetMacros $single_define\n";
    }
  }
  foreach my $flist (@flists) {
    $line .= "CompileFile -type verilog -sv yes -file [concat [expand_file_list \"${flist}\"]]\n";
  }

  my $db_var = &Hydra::Setup::Flow::get_scenario_lib_var($Paramref, "RTL_POWER", "db");
  $line .= sprintf <<EOF;
Elaborate \\
  -top                          $design_name \\
  -dblib                        [concat \"\$$db_var\"] \\
  -system_verilog               true \\
  -scenario_file                db/rtl_power.scn \\
  -enable_dw_synthesis          true \\
  -elaborate_relax_syntax_check true \\
  -elaborate_auto_black_box     true \\
  -elaborate_write_power_db     true \\
  -power_db_name                db/elab.pdb \\
  -elaborate_log                log/elab.log

EOF

  my $sdc  = &Hydra::Util::File::resolve_env($Paramref->get_param_value("RTL_POWER_sdc", "strict"));
  $line .= sprintf <<EOF;
ReadSDC \\
  -top              $design_name \\
  -sdc_files        $sdc \\
  -power_db_name    db/elab.pdb \\
  -sdc_clocks_mode  infer \\
  -sdc_clocks_gated true \\
  -sdc_out_file     output/sdc.scr \\
  -log              log/read_sdc.log

source output/sdc.scr

EOF

  my $cts_buf = &Hydra::Setup::Param::remove_param_value_linebreak($Paramref->get_param_value("RTL_POWER_cts_buf", "strict"));
  my $fanout  = $Paramref->get_param_value("RTL_POWER_cts_max_fanout", "strict");
  my @bufs = split(/\s+/, &Hydra::Setup::Param::remove_param_value_linebreak($cts_buf));
  foreach my $buf (@bufs) {
    $line .= "SetClockBuffer -type leaf -fanout $fanout -name $buf\n";
  }
  $line .= "SetClockGatingStyle -clock_cell_attribute latch_posedge_precontrol\n";
  $line .= "\n";

  my $fsdb      = &Hydra::Util::File::resolve_env($Paramref->get_param_value("RTL_POWER_fsdb", "strict"));
  my $starttime = $Paramref->get_param_value("RTL_POWER_fsdb_starttime", "relaxed");
  my $endtime   = $Paramref->get_param_value("RTL_POWER_fsdb_endtime", "relaxed");
  my $top_name = $Paramref->get_param_value("RTL_POWER_testbench_top", "strict");
  $line .= sprintf <<EOF;
# Comment this command out to re-run without re-reading the fsdb
GenerateGAF \\
  -activity_file $fsdb \\
  -top_instance  $top_name \\
EOF

  if (&Hydra::Setup::Param::has_value($starttime)) {
    $line .= "  -start_time    $starttime \\\n";
  }
  if (&Hydra::Setup::Param::has_value($endtime)) {
    $line .= "  -end_time      $endtime \\\n";
  }

$line .= sprintf <<EOF;
  -scenario_file db/rtl_power.scn \\
  -gaf_file      db/rtl_power.gaf \\
  -gaf_enable_reduction_data true

EOF

  my $wireload_lib = $Paramref->get_param_value("RTL_POWER_wireload_lib", "strict");
  $line .= sprintf <<EOF;
CalculatePower \\
  -wireload_library          $wireload_lib \\
  -analysis_type             average \\
  -use_existing_gaf          true \\
  -gaf_file                  db/rtl_power.gaf \\
  -scenario_file             db/rtl_power.scn \\
  -average_report_options    agipmV \\
  -average_report_file       rpt/avg_power.rpt \\
  -average_write_power_db    true \\
  -detailed_vertical_report  true \\
  -vertical_report_instances $design_name \\
  -power_db_name             db/avg_power.pdb \\
  -calculate_log             log/calc.log

openPDB db/avg_power.pdb
reportPower -show_ibp -levels 10 -unit mW -out rpt/power.rpt
reportSummary -out rpt/summary.rpt
reportCGEfficiency -sort_by clock_power -out rpt/cg_efficiency.rpt -cols {cg_inst cg_type clock_power enable_cum_eff enable_eff enable_duty_cycle clock_freq gated_clock_freq data_freq_out flop_bits direct_flop_bits enable_net enable_sense clock_net file line }
closePDB

ReducePower \\
  -top_instance              $design_name \\
  -wireload_library          $wireload_lib \\
  -use_existing_gaf          true \\
  -gaf_file                  db/rtl_power.gaf \\
  -scenario_file             db/rtl_power.scn \\
  -logic_optimization_report rpt/logic_opt.rpt \\
  -reduction_report_file     rpt/reduce_power.rpt \\
  -power_db_name             db/reduce_power.pdb

exit

EOF

  $ScriptFile->add_line($line);
  push(@ScriptFiles, $ScriptFile);

  return (@LibFiles, @ScriptFiles, $KickoffFile);
}

=pod

=head1 spyglass RTL_POWER

=over

=item RTL_POWER_rtl_flist

An flist containing RTL files. This will be read by Hydra to determine what include directories to pass into the tool.

=item RTL_POWER_sgdc

A SpyGlass Design Constraint file. Optional. If a file is not specified, Hydra will generate a local sgdc with data from other params.

=item RTL_POWER_fsdb

An fsdb file containing waveform data. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_fsdb_starttime

The start time of the waveform in the fsdb. Optional. If not specified, the tool will use the start time embedded in the fsdb. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_fsdb_endtime

The end time of the waveform in the fsdb. Optional. If not specified, the tool will use the end time embedded in the fsdb. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_testbench_top

The top module name of the fsdb. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_sdc

The timing constraint file. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_cts_buf

The clock buffer cell used when estimating the clock tree. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_cts_max_fanout

The max fanout of the clock buffer cell. This will be used if RTL_POWER_sgdc is not specified.

=item RTL_POWER_clock_gating_threshold

Enables clock gating for registers with width greater than or equal to the specified value. Optional.

=item RTL_POWER_enable_scan_ins

Enables usage of scan flops when mapping flops in the design. Optional.

=item RTL_POWER_define

A space-delimited list of `define macros.

=back

=head1 joules RTL_POWER

=over

=item RTL_POWER_rtl_flist

An flist containing RTL files. This will be read by Hydra to determine what include directories to pass into the tool.

=item RTL_POWER_fsdb

An fsdb file containing waveform data.

=item RTL_POWER_fsdb_starttime

The start time of the waveform in the fsdb. Optional. If not specified, the tool will use the start time embedded in the fsdb.

=item RTL_POWER_fsdb_endtime

The end time of the waveform in the fsdb. Optional. If not specified, the tool will use the end time embedded in the fsdb.

=item RTL_POWER_testbench_top

The top module name of the fsdb.

=item RTL_POWER_sdc

The timing constraint file.

=item RTL_POWER_cts_buf

The clock buffer cell used when estimating the clock tree.

=item RTL_POWER_clock_gating_threshold

Enables clock gating for registers with width greater than or equal to the specified value. Optional.

=item RTL_POWER_enable_scan_ins

Enables usage of scan flops when mapping flops in the design. Optional.

=item RTL_POWER_define

A space-delimited list of `define macros.

=back

=head1 powerartist RTL_POWER

=over

=item RTL_POWER_rtl_flist

An flist containing RTL files. This will be read by Hydra to determine what include directories to pass into the tool.

=item RTL_POWER_fsdb

An fsdb file containing waveform data.

=item RTL_POWER_fsdb_starttime

The start time of the waveform in the fsdb. Optional. If not specified, the tool will use the start time embedded in the fsdb.

=item RTL_POWER_fsdb_endtime

The end time of the waveform in the fsdb. Optional. If not specified, the tool will use the end time embedded in the fsdb.

=item RTL_POWER_testbench_top

The top module name of the fsdb.

=item RTL_POWER_sdc

The timing constraint file.

=item RTL_POWER_cts_buf

The clock buffer cell used when estimating the clock tree.

=item RTL_POWER_cts_max_fanout

The max fanout of the clock buffer cell.

=item RTL_POWER_wireload_lib

Specify the library containing the wireload specifications that will be used. Due to a bug in the tool, this must be manually defined.

=item RTL_POWER_enable_scan_ins

Enables usage of scan flops when mapping flops in the design. Optional.

=item RTL_POWER_define

A space-delimited list of `define macros.

=back

=cut

1;
