#------------------------------------------------------
# Module Name: DRC
# Date:        Thu Jun 27 15:11:52 2019
# Author:      kvu
# Type:        drc
#------------------------------------------------------
package Hydra::Setup::Flow::DRC;

use strict;
use warnings;
use Carp;
use Exporter;
use Digest::MD5 qw(md5_hex);

our $VERSION = 1.00;
our @ISA     = qw(Exporter);

#------------------------------------------------------
# Global Variables
#------------------------------------------------------
my $glb_self_module = "$ENV{HYDRA_HOME}/lib/Hydra/Setup/Flow/DRC.pm";

#------------------------------------------------------
# Subroutines
#------------------------------------------------------

# Adds a "../" to a relative path file
sub fix_relative_path {
  my ($filename, $iter_name) = @_;
  if (!defined $iter_name) {
    # Dont modify filename if no iterations were defined
    return $filename;
  }

  if ($filename !~ /^\//) {
    $filename = "../${filename}";
  }

  return $filename;
}

#++
# Tool: icv
# Flow: DRC
#--
sub icv_DRC {
  my ($Paramref, $KickoffFile, $subtype) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  # Self-parse to compile a list of all params used
  # Check each param for keys to determine iterations
  my @param_list  = &Hydra::Setup::Flow::parse_self_for_params($glb_self_module, "icv_DRC");
  my @all_keysets = ();
  foreach my $param_name (@param_list) {
    if ($Paramref->has_param_keysets($param_name, 1)) {
      push(@all_keysets, $Paramref->get_param_keysets($param_name, 1));
    }
  }

  # Remove duplicate keysets
  my %found   = ();
  my @keysets = ();
  foreach my $aref_keys (@all_keysets) {
    if (!defined $found{md5_hex(@$aref_keys)}) {
      push(@keysets, $aref_keys);
      $found{md5_hex(@$aref_keys)} = 1;
    }
  }

  # Add the "default" keyset if there are no keysets
  if (scalar(@keysets) <= 0) {
    push(@keysets, ["default"]);
  }

  #my @keysets = $Paramref->get_param_keysets("SCENARIO", 4);
  my @ScriptFiles = ();
  foreach my $aref_keys (@keysets) {
    my $iter_name;
    my $IterKickoffFile;
    if ($aref_keys->[0] ne "default") {
      my $time = localtime;
      $iter_name = $aref_keys->[0];
      $IterKickoffFile = new Hydra::Setup::File("${iter_name}/HYDRA.${iter_name}", "drc", $subtype);
      $IterKickoffFile->add_line("#!/usr/bin/bash");
      $IterKickoffFile->add_line("# Generated by Hydra on $time");
      $IterKickoffFile->add_line("export HYDRA_HOME=$ENV{HYDRA_HOME}");
      $IterKickoffFile->add_linebreak;
      $IterKickoffFile->add_dir("$iter_name");
      $IterKickoffFile->add_dir("${iter_name}/output");
      $IterKickoffFile->add_dir("${iter_name}/log");
      $IterKickoffFile->make_executable;
      push(@ScriptFiles, $IterKickoffFile);
    }

    my $line = "";

    # Setup
    my $home_dir = &fix_relative_path($Paramref->get_param_value("PV_home_dir", "strict", @$aref_keys), $iter_name);
    $line .= sprintf <<EOF;
source ${home_dir}/setup/icv_setup.sh

EOF

    my $drc_bin   = &Hydra::Setup::Tool::get_tool_binary($Paramref, "drc");
    my $ascii_bin = &fix_relative_path($Paramref->get_param_value("DRC_pydb2ascii_bin", "relaxed", @$aref_keys), $iter_name);
    my $gds;
    my $deck;
    if (defined $subtype && $subtype eq "fullchip") {
      # The following comments are used in &parse_self_for_params to avoid parsing special subtype params
      # StartParseSelfSubtype: fullchip
      $gds  = &fix_relative_path($Paramref->get_param_value("PV_FULLCHIP_gds", "strict", @$aref_keys), $iter_name);
      $deck = &fix_relative_path($Paramref->get_param_value("DRC_FULLCHIP_deck", "strict", @$aref_keys), $iter_name);
      # EndParseSelfSubtype: fullchip
    }
    else {
      # StartParseSelfSubtype: HYDRA_UNDEF
      $gds  = &fix_relative_path($Paramref->get_param_value("PV_gds", "strict", @$aref_keys), $iter_name);
      $deck = &fix_relative_path($Paramref->get_param_value("DRC_deck", "strict", @$aref_keys), $iter_name);
      # EndParseSelfSubtype: HYDRA_UNDEF
    }

    $line .= sprintf <<EOF;
$drc_bin -vue -dp8 \\
  -i ${gds} \\
  -c ${design_name} \\
  ${deck} \\
|& tee log/drc.log

EOF

    if (&Hydra::Setup::Param::has_value($ascii_bin)) {
      $line .= sprintf <<EOF;
$ascii_bin -c \\
  -pydb_path ./run_details/pydb \\
  -pydb_name PYDB_${design_name} \\
  -sa        ./output/${design_name}.pydb.ascii \\
|& tee log/pydb2ascii.log

gzip -f ./*.gds
gzip -f ./output/*.gds
EOF
    }

    if (defined $iter_name) {
      $KickoffFile->add_line("# Iteration $iter_name");
      $KickoffFile->add_line("cd $iter_name");
      $KickoffFile->add_linebreak;
      $KickoffFile->add_line($line);
      $KickoffFile->add_line("cd ..");
      $KickoffFile->add_linebreak;
      $KickoffFile->add_linebreak;

      $IterKickoffFile->add_line($line);
    }
    else {
      $KickoffFile->add_line($line);
    }
  }
  $KickoffFile->make_executable;

  return ($KickoffFile, @ScriptFiles);
}

#++
# Tool: icv
# Flow: DRC_FULLCHIP
# Subtype: fullchip
#--
sub icv_DRC_FULLCHIP {
  my ($Paramref, $KickoffFile) = @_;
  return &icv_DRC($Paramref, $KickoffFile, "fullchip");
}

#++
# Tool: calibre
# Flow: DRC
#--
sub calibre_DRC {
  my ($Paramref, $KickoffFile, $subtype) = @_;
  my $design_name = $Paramref->get_param_value("GLOBAL_design", "strict");

  my $ScriptFile = new Hydra::Setup::File("script/drc.rules.svrf", "drc", $subtype);
  my $line = "";
  my $drc_bin   = &Hydra::Setup::Tool::get_tool_binary($Paramref, "drc");
  my $gds;
  my $deck;
  if (defined $subtype && $subtype eq "fullchip") {
    $gds  = $Paramref->get_param_value("PV_FULLCHIP_gds", "strict");
    $deck = $Paramref->get_param_value("DRC_FULLCHIP_deck", "strict");
  }
  else {
    $gds  = $Paramref->get_param_value("PV_gds", "strict");
    $deck = $Paramref->get_param_value("DRC_deck", "strict");
  }
  $line .= sprintf <<EOF;
INCLUDE $deck

LAYOUT SYSTEM  GDSII
LAYOUT PATH    "$gds"
LAYOUT PRIMARY $design_name

DRC RESULTS DATABASE  "./output/${design_name}.drc.db"
DRC SUMMARY REPORT    "./rpt/${design_name}.drc.rpt"

EOF

  $ScriptFile->add_line($line);
  
  $KickoffFile->add_line("$drc_bin -drc -64 script/drc.rules.svrf | tee log/drc.rules.log\n\n");
  $KickoffFile->make_executable;

  return ($ScriptFile, $KickoffFile);
}

#++
# Tool: calibre
# Flow: DRC_FULLCHIP
# Subtype: fullchip
#--
sub calibre_DRC_FULLCHIP {
  my ($Paramref, $KickoffFile) = @_;
  return &caliabre_DRC($Paramref, $KickoffFile, "fullchip");
}

=pod

=head1 icv DRC

Multiple iterations of DRC can be generated using param keys. Define a param key on any DRC param to active. If one or more iterations are defined, then each iteration will reside in its own generated subdirectory. Any input files with a relative path will have "../" prepended to work in each subdirectory.

 DRC_deck(base_fill)  = Dummy_OD_PO_ICV_28nm_HP.13a
 DRC_deck(metal_fill) = Dummy_Metal_Via_ICV_28nm.13b

=over

=item PV_home_dir

The home directory of ICV. This is used to set necessary environment variables for ICV.

=item PV_gds

The gds to perform DRC on.

=item DRC_deck

The deck to perform DRC with.

=item DRC_pydb2ascii_bin

The binary path to the tool for converting the output DRC markers to a readable format for ICC2.

=back

=head1 icv DRC_FULLCHIP

=over

DRC_FULLCHIP uses all the same params as DRC, along with the following:

=item PV_FULLCHIP_gds

The gds to perform DRC on.

=item DRC_FULLCHIP_deck

The deck to perform DRC with.

=back

=head1 calibre DRC

=over

=item PV_gds

The gds to perform DRC on.

=item DRC_deck

The deck to perform DRC with.

=back

=head1 calibre DRC_FULLCHIP

=over

DRC_FULLCHIP uses all the same params as DRC, along with the following:

=item PV_FULLCHIP_gds

The gds to perform DRC on.

=item DRC_FULLCHIP_deck

The deck to perform DRC with.

=back

=cut

1;
